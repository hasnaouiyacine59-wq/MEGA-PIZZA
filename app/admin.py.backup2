from flask import Blueprint, render_template, redirect, url_for, flash, request, jsonify, current_app
from flask_login import login_required, current_user
from functools import wraps
from .models import User, Driver, Restaurant, Customer, Order, db, Address, MenuItem, OrderItem, OrderStatusHistory
from .forms import DriverRegistrationForm, DriverEditForm
from datetime import datetime, timedelta
import traceback
import math
from sqlalchemy import func, desc, or_

admin_bp = Blueprint('admin', __name__)


# ============================================
# HELPER FUNCTIONS
# ============================================
def require_admin():
    """Check if current user is admin"""
    if not current_user.is_authenticated:
        return False
    return current_user.is_admin()

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not require_admin():
            flash('Administrator access required.', 'danger')
            return redirect(url_for('auth.login'))
        return f(*args, **kwargs)
    return decorated_function

# Import csrf_protect from csrf module
from .csrf import csrf_protect

# ============================================
# MENU ITEMS MANAGEMENT (COMPLETE IMPLEMENTATION)
# ============================================
@admin_bp.route('/menu-items')
@login_required
@admin_required
def manage_menu_items():
    # Get filter parameters
    page = request.args.get('page', 1, type=int)
    per_page = 20
    
    restaurant_id = request.args.get('restaurant_id', '')
    category = request.args.get('category', '')
    availability = request.args.get('availability', '')
    search = request.args.get('search', '')
    
    # Build query
    query = MenuItem.query.join(Restaurant)
    
    # Apply filters
    if restaurant_id and restaurant_id != 'all':
        query = query.filter(MenuItem.restaurant_id == restaurant_id)
    
    if category and category != 'all':
        query = query.filter(MenuItem.category == category)
    
    if availability == 'available':
        query = query.filter(MenuItem.is_available == True)
    elif availability == 'unavailable':
        query = query.filter(MenuItem.is_available == False)
    
    if search:
        search_term = f"%{search}%"
        query = query.filter(
            or_(
                MenuItem.name.ilike(search_term),
                MenuItem.description.ilike(search_term),
                MenuItem.category.ilike(search_term)
            )
        )
    
    # Get total count before pagination
    total_items = query.count()
    
    # Calculate total pages
    total_pages = math.ceil(total_items / per_page) if total_items > 0 else 1
    
    # Ensure page is within bounds
    if page > total_pages:
        page = total_pages
    if page < 1:
        page = 1
    
    # Apply pagination
    menu_items = query.order_by(MenuItem.created_at.desc())\
                      .offset((page - 1) * per_page)\
                      .limit(per_page)\
                      .all()
    
    # Get all restaurants for filter dropdown
    restaurants = Restaurant.query.order_by(Restaurant.name).all()
    
    # Get unique categories from database
    categories = db.session.query(MenuItem.category)\
                          .distinct()\
                          .order_by(MenuItem.category)\
                          .all()
    categories = [cat[0] for cat in categories if cat[0]]
    
    return render_template('admin/manage_menu_items.html',
                         menu_items=menu_items,
                         restaurants=restaurants,
                         categories=categories,
                         total_items=total_items,
                         current_page=page,
                         total_pages=total_pages,
                         per_page=per_page,
                         has_prev=page > 1,
                         has_next=page < total_pages)


@admin_bp.route('/menu-items', methods=['POST'])
@login_required
@admin_required
@csrf_protect()  # Now this works from the csrf module
def add_menu_item():
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({
                'success': False, 
                'message': 'No data provided'
            })
        
        # Validate required fields
        required_fields = ['name', 'price', 'restaurant_id', 'category']
        for field in required_fields:
            if not data.get(field):
                return jsonify({
                    'success': False, 
                    'message': f'{field.replace("_", " ").title()} is required'
                })
        
        # Validate price
        try:
            price = float(data['price'])
            if price <= 0:
                return jsonify({
                    'success': False, 
                    'message': 'Price must be greater than 0'
                })
        except ValueError:
            return jsonify({
                'success': False, 
                'message': 'Invalid price value'
            })
        
        # Check if restaurant exists
        restaurant = Restaurant.query.get(data['restaurant_id'])
        if not restaurant:
            return jsonify({
                'success': False, 
                'message': 'Restaurant not found'
            })
        
        # Create new menu item
        new_item = MenuItem(
            name=data['name'].strip(),
            description=data.get('description', '').strip(),
            price=price,
            restaurant_id=data['restaurant_id'],
            category=data['category'].strip(),
            image_url=data.get('image_url', '').strip() or None,
            is_available=data.get('is_available', True) in [True, 'true', 'on', '1'],
            created_at=datetime.utcnow()
        )
        
        db.session.add(new_item)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Menu item added successfully',
            'item_id': new_item.item_id
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Error adding menu item: {str(e)}')
        return jsonify({
            'success': False, 
            'message': 'Failed to add menu item. Please try again.'
        })


@admin_bp.route('/menu-items/<item_id>', methods=['PUT'])
@login_required
@admin_required
@csrf_protect()
def update_menu_item(item_id):
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({
                'success': False, 
                'message': 'No data provided'
            })
        
        # Get the menu item
        menu_item = MenuItem.query.get_or_404(item_id)
        
        # Validate required fields
        required_fields = ['name', 'price', 'restaurant_id', 'category']
        for field in required_fields:
            if not data.get(field):
                return jsonify({
                    'success': False, 
                    'message': f'{field.replace("_", " ").title()} is required'
                })
        
        # Validate price
        try:
            price = float(data['price'])
            if price <= 0:
                return jsonify({
                    'success': False, 
                    'message': 'Price must be greater than 0'
                })
        except ValueError:
            return jsonify({
                'success': False, 
                'message': 'Invalid price value'
            })
        
        # Check if restaurant exists
        restaurant = Restaurant.query.get(data['restaurant_id'])
        if not restaurant:
            return jsonify({
                'success': False, 
                'message': 'Restaurant not found'
            })
        
        # Update menu item
        menu_item.name = data['name'].strip()
        menu_item.description = data.get('description', '').strip()
        menu_item.price = price
        menu_item.restaurant_id = data['restaurant_id']
        menu_item.category = data['category'].strip()
        menu_item.image_url = data.get('image_url', '').strip() or None
        menu_item.is_available = data.get('is_available', True) in [True, 'true', 'on', '1']
        menu_item.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Menu item updated successfully',
            'item_id': menu_item.item_id
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Error updating menu item: {str(e)}')
        return jsonify({
            'success': False, 
            'message': 'Failed to update menu item. Please try again.'
        })


@admin_bp.route('/menu-items/<item_id>/toggle-availability', methods=['POST'])
@login_required
@admin_required
@csrf_protect()
def toggle_menu_item_availability(item_id):
    try:
        data = request.get_json()
        menu_item = MenuItem.query.get_or_404(item_id)
        
        # Toggle availability
        if 'is_available' in data:
            menu_item.is_available = data['is_available']
        else:
            menu_item.is_available = not menu_item.is_available
        
        menu_item.updated_at = datetime.utcnow()
        db.session.commit()
        
        status = "available" if menu_item.is_available else "unavailable"
        
        return jsonify({
            'success': True,
            'message': f'Menu item is now {status}',
            'is_available': menu_item.is_available
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Error toggling menu item availability: {str(e)}')
        return jsonify({
            'success': False, 
            'message': 'Failed to update availability. Please try again.'
        })


@admin_bp.route('/menu-items/<item_id>', methods=['DELETE'])
@login_required
@admin_required
@csrf_protect()
def delete_menu_item(item_id):
    try:
        menu_item = MenuItem.query.get_or_404(item_id)
        
        # Check if item is in any orders
        order_items = OrderItem.query.filter_by(item_id=item_id).first()
        if order_items:
            return jsonify({
                'success': False,
                'message': 'Cannot delete menu item that is associated with orders. Mark it as unavailable instead.'
            })
        
        # Delete the menu item
        db.session.delete(menu_item)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Menu item deleted successfully'
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Error deleting menu item: {str(e)}')
        return jsonify({
            'success': False, 
            'message': 'Failed to delete menu item. Please try again.'
        })


@admin_bp.route('/menu-items/<item_id>/edit')
@login_required
@admin_required
def edit_menu_item_form(item_id):
    menu_item = MenuItem.query.get_or_404(item_id)
    restaurants = Restaurant.query.order_by(Restaurant.name).all()
    
    # Get unique categories from database
    categories = db.session.query(MenuItem.category)\
                          .distinct()\
                          .order_by(MenuItem.category)\
                          .all()
    categories = [cat[0] for cat in categories if cat[0]]
    
    return render_template('admin/edit_menu_item.html',
                         item=menu_item,
                         restaurants=restaurants,
                         categories=categories)


# Add context processor for template utilities
@admin_bp.context_processor
def utility_processor():
    def remove_arg(arg_name):
        """Remove an argument from request.args and return the rest"""
        args = request.args.copy()
        if arg_name in args:
            args.pop(arg_name)
        return args.to_dict()
    
    return dict(remove_arg=remove_arg)


# ============================================
# DASHBOARD (Keep existing)
# ============================================
@admin_bp.route('/dashboard')
@login_required
@admin_required
def dashboard():
    # Get statistics
    stats = {
        'total_users': User.query.count(),
        'active_users': User.query.filter_by(is_active=True).count(),
        'admins': User.query.filter_by(role='admin').count(),
        'drivers': User.query.filter_by(role='driver').count(),
        'managers': User.query.filter_by(role='manager').count(),
        'employees': User.query.filter_by(role='employee').count(),
        'customers': User.query.filter_by(role='user').count(),
        'restaurants_count': Restaurant.query.count(),
        'active_drivers': Driver.query.filter_by(is_available=True).count(),
        'on_shift_drivers': Driver.query.filter_by(is_on_shift=True).count(),
        'total_orders': Order.query.count(),
        'pending_orders': Order.query.filter_by(order_status='pending').count(),
        'active_orders': Order.query.filter(
            Order.order_status.in_(['confirmed', 'preparing', 'ready', 'out_for_delivery'])
        ).count(),
        'today_orders': Order.query.filter(
            db.func.date(Order.created_at) == datetime.today().date()
        ).count()
    }
    
    # Get recent orders
    recent_orders = Order.query.order_by(Order.created_at.desc()).limit(10).all()
    
    # Get top drivers
    top_drivers = Driver.query.order_by(Driver.rating.desc(), Driver.completed_deliveries.desc()).limit(5).all()
    
    # Get restaurant stats
    restaurants = Restaurant.query.all()
    
    return render_template('admin/dashboard.html',
                         stats=stats,
                         recent_orders=recent_orders,
                         top_drivers=top_drivers,
                         restaurants=restaurants,
                         current_time=datetime.now())


# ============================================
# DRIVER MANAGEMENT (Keep existing)
# ============================================
@admin_bp.route('/drivers')
@login_required
@admin_required
def manage_drivers():
    drivers = Driver.query.join(User).all()
    
    total_drivers = len(drivers)
    available_drivers = len([d for d in drivers if d.is_available])
    on_shift_drivers = len([d for d in drivers if d.is_on_shift])
    
    if drivers:
        avg_rating = sum(float(d.rating or 0) for d in drivers) / len(drivers)
    else:
        avg_rating = 0.0
    
    return render_template('admin/manage_drivers.html',
                         drivers=drivers,
                         total_drivers=total_drivers,
                         available_drivers=available_drivers,
                         on_shift_drivers=on_shift_drivers,
                         avg_rating=avg_rating)


@admin_bp.route('/drivers/add', methods=['GET', 'POST'])
@login_required
@admin_required
@csrf_protect()
def add_driver():
    form = DriverRegistrationForm()
    
    if form.validate_on_submit():
        existing_user = User.query.filter(
            (User.username == form.username.data) | 
            (User.email == form.email.data)
        ).first()
        
        if existing_user:
            flash('Username or email already exists', 'danger')
            return render_template('admin/add_driver.html', form=form)
        
        try:
            user = User(
                username=form.username.data,
                email=form.email.data,
                phone_number=form.phone.data,
                role='driver',
                is_active=True
            )
            user.password = form.password.data
            
            db.session.add(user)
            db.session.flush()
            
            driver = Driver(
                user_id=user.user_id,
                license_number=form.license_number.data,
                vehicle_type=form.vehicle_type.data,
                vehicle_model=form.vehicle_model.data,
                license_plate=form.license_plate.data,
                emergency_contact=form.emergency_contact.data,
                emergency_phone=form.emergency_phone.data,
                shift_start=form.shift_start.data,
                shift_end=form.shift_end.data,
                is_available=form.is_available.data,
                is_on_shift=form.is_on_shift.data
            )
            
            db.session.add(driver)
            db.session.commit()
            
            flash(f'Driver {form.username.data} added successfully!', 'success')
            return redirect(url_for('admin.manage_drivers'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error adding driver: {str(e)}', 'danger')
    
    return render_template('admin/add_driver.html', form=form)


@admin_bp.route('/drivers/<int:driver_id>/edit', methods=['GET', 'POST'])
@login_required
@admin_required
@csrf_protect()
def edit_driver(driver_id):
    driver = Driver.query.get_or_404(driver_id)
    user = driver.user
    
    form = DriverEditForm()
    
    if form.validate_on_submit():
        user.username = form.username.data
        user.email = form.email.data
        user.phone_number = form.phone.data
        user.is_active = form.status.data == 'active'
        
        if form.password.data:
            user.password = form.password.data
        
        driver.license_number = form.license_number.data
        driver.vehicle_type = form.vehicle_type.data
        driver.vehicle_model = form.vehicle_model.data
        driver.license_plate = form.license_plate.data
        driver.emergency_contact = form.emergency_contact.data
        driver.emergency_phone = form.emergency_phone.data
        driver.shift_start = form.shift_start.data
        driver.shift_end = form.shift_end.data
        driver.is_available = form.is_available.data
        driver.is_on_shift = form.is_on_shift.data
        
        try:
            db.session.commit()
            flash(f'Driver {user.username} updated successfully!', 'success')
            return redirect(url_for('admin.manage_drivers'))
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating driver: {str(e)}', 'danger')
    
    if request.method == 'GET':
        form.username.data = user.username
        form.email.data = user.email
        form.phone.data = user.phone_number
        form.status.data = 'active' if user.is_active else 'inactive'
        form.license_number.data = driver.license_number
        form.vehicle_type.data = driver.vehicle_type
        form.vehicle_model.data = driver.vehicle_model
        form.license_plate.data = driver.license_plate
        form.emergency_contact.data = driver.emergency_contact
        form.emergency_phone.data = driver.emergency_phone
        form.shift_start.data = driver.shift_start
        form.shift_end.data = driver.shift_end
        form.is_available.data = driver.is_available
        form.is_on_shift.data = driver.is_on_shift
    
    return render_template('admin/edit_driver.html', form=form, driver=driver)


@admin_bp.route('/drivers/<int:driver_id>/toggle-availability', methods=['POST'])
@login_required
@admin_required
@csrf_protect()
def toggle_driver_availability(driver_id):
    driver = Driver.query.get_or_404(driver_id)
    
    try:
        driver.is_available = not driver.is_available
        db.session.commit()
        return jsonify({
            'success': True,
            'message': f'Driver availability {"enabled" if driver.is_available else "disabled"}',
            'is_available': driver.is_available
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500


@admin_bp.route('/drivers/<int:driver_id>/delete', methods=['DELETE'])
@login_required
@admin_required
@csrf_protect()
def delete_driver(driver_id):
    try:
        driver = Driver.query.get(driver_id)
        if not driver:
            return jsonify({'success': False, 'message': 'Driver not found'}), 404
        
        active_orders = Order.query.filter(
            Order.driver_id == driver_id,
            Order.order_status.in_(['confirmed', 'preparing', 'ready', 'out_for_delivery'])
        ).count()
        
        if active_orders > 0:
            return jsonify({
                'success': False, 
                'message': f'Cannot delete driver with {active_orders} active order(s). Please reassign orders first.'
            }), 400
        
        user = driver.user
        
        db.session.delete(driver)
        
        if user:
            db.session.delete(user)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Driver deleted successfully',
            'redirect': url_for('admin.manage_drivers')
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500


# ============================================
# ORDER MANAGEMENT (Keep existing)
# ============================================
@admin_bp.route('/orders')
@login_required
@admin_required
def manage_orders():
    status = request.args.get('status', 'all')
    restaurant_id = request.args.get('restaurant_id', 'all')
    search = request.args.get('search', '')
    payment_status = request.args.get('payment_status', 'all')
    start_date = request.args.get('start_date', '')
    end_date = request.args.get('end_date', '')
    
    query = Order.query
    
    if status != 'all':
        query = query.filter_by(order_status=status)
    
    if restaurant_id != 'all':
        query = query.filter_by(restaurant_id=restaurant_id)
    
    if payment_status != 'all':
        query = query.filter_by(payment_status=payment_status)
    
    if search:
        search_term = f"%{search}%"
        query = query.join(Customer).filter(
            (Order.order_id.ilike(search_term)) |
            (Customer.name.ilike(search_term)) |
            (Customer.phone_number.ilike(search_term))
        )
    
    if start_date:
        query = query.filter(Order.created_at >= datetime.strptime(start_date, '%Y-%m-%d'))
    if end_date:
        end_date_obj = datetime.strptime(end_date, '%Y-%m-%d') + timedelta(days=1)
        query = query.filter(Order.created_at < end_date_obj)
    
    orders = query.order_by(Order.created_at.desc()).all()
    
    restaurants = Restaurant.query.all()
    
    today = datetime.now().date()
    stats = {
        'total_orders': Order.query.count(),
        'pending_orders': Order.query.filter_by(order_status='pending').count(),
        'active_orders': Order.query.filter(
            Order.order_status.in_(['confirmed', 'preparing', 'ready', 'out_for_delivery'])
        ).count(),
        'delivered_orders': Order.query.filter_by(order_status='delivered').count(),
        'cancelled_orders': Order.query.filter_by(order_status='cancelled').count(),
        'total_revenue': db.session.query(func.sum(Order.total_amount)).scalar() or 0,
        'today_orders': Order.query.filter(
            db.func.date(Order.created_at) == today
        ).count(),
        'delivered_today': Order.query.filter(
            db.func.date(Order.delivered_at) == today,
            Order.order_status == 'delivered'
        ).count()
    }
    
    available_drivers = Driver.query.filter_by(is_available=True).all()
    
    return render_template('admin/manage_orders.html',
                         orders=orders,
                         restaurants=restaurants,
                         stats=stats,
                         available_drivers=available_drivers,
                         current_status=status,
                         current_restaurant=restaurant_id,
                         search=search,
                         payment_status=payment_status,
                         start_date=start_date,
                         end_date=end_date)


@admin_bp.route('/orders/<string:order_id>/update-status', methods=['POST'])
@login_required
@admin_required
@csrf_protect()
def update_order_status(order_id):
    order = Order.query.get_or_404(order_id)
    data = request.get_json()
    
    try:
        old_status = order.order_status
        new_status = data.get('new_status')
        driver_id = data.get('driver_id')
        notes = data.get('notes')
        
        if not new_status:
            return jsonify({'success': False, 'message': 'No status provided'})
        
        order.order_status = new_status
        
        if driver_id and new_status == 'out_for_delivery':
            driver = Driver.query.get(driver_id)
            if driver:
                order.driver_id = driver.driver_id
                driver.is_available = False
                driver.total_deliveries = (driver.total_deliveries or 0) + 1
        
        if new_status == 'delivered':
            order.delivered_at = datetime.utcnow()
        elif new_status == 'out_for_delivery':
            order.estimated_delivery = datetime.utcnow() + timedelta(minutes=30)
        
        history = OrderStatusHistory(
            order_id=order.order_id,
            old_status=old_status,
            new_status=new_status,
            changed_by=current_user.user_id,
            public_notes=notes,
            actor_type='admin',
            source='admin_panel'
        )
        db.session.add(history)
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Status updated successfully'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)})


# ============================================
# OTHER MANAGEMENT ROUTES (Keep existing)
# ============================================
@admin_bp.route('/categories')
@login_required
@admin_required
def manage_categories():
    categories = db.session.query(
        MenuItem.category,
        func.count(MenuItem.item_id).label('item_count'),
        func.sum(MenuItem.price).label('total_value')
    ).group_by(MenuItem.category)\
     .order_by(MenuItem.category)\
     .all()
    
    category_list = []
    for cat in categories:
        category_list.append({
            'name': cat[0] or 'Uncategorized',
            'item_count': cat[1],
            'total_value': cat[2] or 0
        })
    
    return render_template('admin/manage_categories.html',
                         categories=category_list)


@admin_bp.route('/customers')
@login_required
@admin_required
def manage_customers():
    search = request.args.get('search', '')
    
    query = Customer.query
    
    if search:
        search_term = f"%{search}%"
        query = query.filter(
            (Customer.name.ilike(search_term)) |
            (Customer.phone_number.ilike(search_term)) |
            (Customer.email.ilike(search_term)) |
            (Customer.customer_id.ilike(search_term))
        )
    
    customers = query.order_by(Customer.created_at.desc()).all()
    
    total_customers = Customer.query.count()
    customers_with_orders = db.session.query(func.count(func.distinct(Order.customer_id))).scalar()
    recent_customers = Customer.query.order_by(Customer.created_at.desc()).limit(5).all()
    
    return render_template('admin/manage_customers.html',
                         customers=customers,
                         total_customers=total_customers,
                         customers_with_orders=customers_with_orders,
                         recent_customers=recent_customers,
                         search=search)


@admin_bp.route('/restaurants')
@login_required
@admin_required
def manage_restaurants():
    restaurants = Restaurant.query.all()
    
    restaurants_with_stats = []
    for restaurant in restaurants:
        orders_count = Order.query.filter_by(restaurant_id=restaurant.restaurant_id).count()
        total_revenue = db.session.query(func.sum(Order.total_amount))\
            .filter(Order.restaurant_id == restaurant.restaurant_id)\
            .scalar() or 0
        
        restaurants_with_stats.append({
            'restaurant': restaurant,
            'orders_count': orders_count,
            'total_revenue': total_revenue,
            'is_active': restaurant.is_active,
            'is_open': restaurant.is_open
        })
    
    return render_template('admin/manage_restaurants.html',
                         restaurants=restaurants_with_stats)


# ============================================
# SYSTEM MANAGEMENT (Keep existing)
# ============================================
@admin_bp.route('/system/health')
@login_required
@admin_required
def system_health():
    try:
        db.session.execute('SELECT 1')
        db_status = 'Healthy'
        db_message = 'Database connection successful'
    except Exception as e:
        db_status = 'Unhealthy'
        db_message = f'Database error: {str(e)}'
    
    stats = {
        'database': {
            'status': db_status,
            'message': db_message,
            'users_count': User.query.count(),
            'orders_count': Order.query.count(),
            'drivers_count': Driver.query.count(),
            'restaurants_count': Restaurant.query.count()
        },
        'application': {
            'start_time': current_app.config.get('START_TIME', 'Unknown'),
            'debug_mode': current_app.debug,
            'environment': current_app.config.get('ENV', 'production')
        }
    }
    
    return render_template('admin/system_health.html', stats=stats)


@admin_bp.route('/create-admin')
def create_admin():
    admin = User.query.filter_by(username='admin').first()
    
    if admin:
        admin.password = 'Admin@123'
        db.session.commit()
        flash('Admin password updated! Username: admin, Password: Admin@123', 'success')
    else:
        admin = User(
            username='admin',
            email='admin@megapizza.com',
            role='admin',
            is_active=True
        )
        admin.password = 'Admin@123'
        db.session.add(admin)
        db.session.commit()
        flash('Admin user created successfully! Username: admin, Password: Admin@123', 'success')
    
    return redirect(url_for('auth.login'))

@admin_bp.route('/users')
@login_required
@admin_required


# ============================================
# MISSING ENDPOINTS FOR TEMPLATE LINKS
# ============================================

@admin_bp.route('/users')
@login_required
@admin_required
def manage_users():
    """Placeholder for user management - redirect to customers"""
    return redirect(url_for('admin.manage_customers'))


@admin_bp.route('/reviews')
@login_required
@admin_required
def manage_reviews():
    """Placeholder for reviews management - show message"""
    flash('Reviews management is not implemented yet.', 'info')
    return redirect(url_for('admin.dashboard'))


@admin_bp.route('/promotions')
@login_required
@admin_required
def manage_promotions():
    """Placeholder for promotions management - show message"""
    flash('Promotions management is not implemented yet.', 'info')
    return redirect(url_for('admin.dashboard'))


@admin_bp.route('/analytics')
@login_required
@admin_required
def manage_analytics():
    """Placeholder for analytics - show message"""
    flash('Analytics dashboard is not implemented yet.', 'info')
    return redirect(url_for('admin.dashboard'))


@admin_bp.route('/settings')
@login_required
@admin_required
def manage_settings():
    """Placeholder for settings - show message"""
    flash('System settings is not implemented yet.', 'info')
    return redirect(url_for('admin.dashboard'))


@admin_bp.route('/notifications')
@login_required
@admin_required
def manage_notifications():
    """Placeholder for notifications - show message"""
    flash('Notifications management is not implemented yet.', 'info')
    return redirect(url_for('admin.dashboard'))


@admin_bp.route('/help')
@login_required
@admin_required
def manage_help():
    """Placeholder for help - show message"""
    flash('Help section is not implemented yet.', 'info')
    return redirect(url_for('admin.dashboard'))